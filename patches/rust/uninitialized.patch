C compilers generally offer warnings about various uses of uninitialized
variables. But a lot of code relies on the assumption that as long as a
variable is written to before it's read, everything's fine--and often
the write is in a different function than the read, making it very
difficult to statically check that the assumption is satisfied. So C
compilers are fairly lenient about this.

Rust, on the other hand, is strict about variable initialization. If the
Rust compiler can't prove that the variable is initialized before it is
read, then the program is rejected.

Corrode can't automatically determine whether a given use of an
uninitialized variable is safe, so we have to patch the generated source
anywhere that the Rust compiler complains.

Index: b/src/vers_ts.rs
===================================================================
--- a/src/vers_ts.rs
+++ b/src/vers_ts.rs
@@ -252,7 +252,7 @@ pub unsafe extern fn Version_TS(
             (*vers_ts).vn_rcs = Xstrdup((*vers_ts).vn_user as (*const u8));
             (*vers_ts).vn_tag = Xstrdup((*vers_ts).vn_user as (*const u8));
         } else {
-            let mut simple : i32;
+            let mut simple : i32 = 0;
             (*vers_ts).vn_rcs = RCS_getversion(
                                     rcsdata,
                                     (*vers_ts).tag as (*const u8),
@@ -272,12 +272,7 @@ pub unsafe extern fn Version_TS(
             if server_active != 0 {
                 server_modtime(finfo,vers_ts);
             } else {
-                let mut t : utimbuf;
-                memset(
-                    &mut t as (*mut utimbuf) as (*mut ::std::os::raw::c_void),
-                    0i32,
-                    ::std::mem::size_of::<utimbuf>()
-                );
+                let mut t : utimbuf = ::std::mem::zeroed();
                 t.modtime = RCS_getrevtime(
                                 rcsdata,
                                 (*vers_ts).vn_rcs as (*const u8),
@@ -333,7 +328,7 @@ unsafe extern fn time_stamp_server(
     mut vers_ts : *mut vers_ts,
     mut entdata : *mut entnode
 ) {
-    let mut sb : stat;
+    let mut sb : stat = ::std::mem::zeroed();
     if lstat(file,&mut sb as (*mut stat)) < 0i32 {
         if !(*__errno_location() == 2i32) {
             error(
@@ -411,7 +406,7 @@ pub unsafe extern fn entries_time(mut un
 
 #[no_mangle]
 pub unsafe extern fn unix_time_stamp(mut file : *const u8) -> isize {
-    let mut sb : stat;
+    let mut sb : stat = ::std::mem::zeroed();
     let mut mtime : isize = 0isize;
     if lstat(file,&mut sb as (*mut stat)) == 0 {
         mtime = sb.st_mtim.tv_sec;
Index: b/src/wrapper.rs
===================================================================
--- a/src/wrapper.rs
+++ b/src/wrapper.rs
@@ -2,7 +2,7 @@ extern {
     fn Xasprintf(format : *const u8, ...) -> *mut u8;
     fn Xstrdup(str : *const u8) -> *mut u8;
     fn __errno_location() -> *mut i32;
-    fn abort();
+    fn abort() -> !;
     static mut current_parsed_root : *mut cvsroot_s;
     fn cvs_temp_name() -> *mut u8;
     fn error(
@@ -33,9 +33,6 @@ extern {
     ) -> isize;
     fn isfile(file : *const u8) -> bool;
     fn isspace(arg1 : i32) -> i32;
-    fn memset(
-        __s : *mut ::std::os::raw::c_void, __c : i32, __n : usize
-    ) -> *mut ::std::os::raw::c_void;
     fn run_exec(
         stin : *const u8, stout : *const u8, sterr : *const u8, flags : i32
     ) -> i32;
@@ -408,17 +405,12 @@ unsafe extern fn streq(
 pub unsafe extern fn wrap_add(mut line : *mut u8, mut isTemp : i32) {
     let mut temp : *mut u8;
     let mut ctemp : u8;
-    let mut e : Struct1;
+    let mut e : Struct1 = ::std::mem::zeroed();
     let mut opt : u8;
     if line.is_null() || *line.offset(
                               0i32 as (isize)
                           ) as (i32) == b'#' as (i32) {
     } else {
-        memset(
-            &mut e as (*mut Struct1) as (*mut ::std::os::raw::c_void),
-            0i32,
-            ::std::mem::size_of::<Struct1>()
-        );
         'loop2: loop {
             if *line != 0 && (isspace(*line as (i32)) != 0) {
                 line = line.offset(1 as (isize));
