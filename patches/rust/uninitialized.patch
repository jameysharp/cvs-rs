C compilers generally offer warnings about various uses of uninitialized
variables. But a lot of code relies on the assumption that as long as a
variable is written to before it's read, everything's fine--and often
the write is in a different function than the read, making it very
difficult to statically check that the assumption is satisfied. So C
compilers are fairly lenient about this.

Rust, on the other hand, is strict about variable initialization. If the
Rust compiler can't prove that the variable is initialized before it is
read, then the program is rejected.

Corrode can't automatically determine whether a given use of an
uninitialized variable is safe, so we have to patch the generated source
anywhere that the Rust compiler complains.

Index: b/src/vers_ts.rs
===================================================================
--- a/src/vers_ts.rs
+++ b/src/vers_ts.rs
@@ -252,7 +252,7 @@ pub unsafe extern fn Version_TS(
             (*vers_ts).vn_rcs = Xstrdup((*vers_ts).vn_user as (*const u8));
             (*vers_ts).vn_tag = Xstrdup((*vers_ts).vn_user as (*const u8));
         } else {
-            let mut simple : i32;
+            let mut simple : i32 = 0;
             (*vers_ts).vn_rcs = RCS_getversion(
                                     rcsdata,
                                     (*vers_ts).tag as (*const u8),
@@ -272,12 +272,7 @@ pub unsafe extern fn Version_TS(
             if server_active != 0 {
                 server_modtime(finfo,vers_ts);
             } else {
-                let mut t : utimbuf;
-                memset(
-                    &mut t as (*mut utimbuf) as (*mut ::std::os::raw::c_void),
-                    0i32,
-                    ::std::mem::size_of::<utimbuf>()
-                );
+                let mut t : utimbuf = ::std::mem::zeroed();
                 t.modtime = RCS_getrevtime(
                                 rcsdata,
                                 (*vers_ts).vn_rcs as (*const u8),
@@ -333,7 +328,7 @@ unsafe extern fn time_stamp_server(
     mut vers_ts : *mut vers_ts,
     mut entdata : *mut entnode
 ) {
-    let mut sb : stat;
+    let mut sb : stat = ::std::mem::zeroed();
     if lstat(file,&mut sb as (*mut stat)) < 0i32 {
         if !(*__errno_location() == 2i32) {
             error(
@@ -411,7 +406,7 @@ pub unsafe extern fn entries_time(mut un
 
 #[no_mangle]
 pub unsafe extern fn unix_time_stamp(mut file : *const u8) -> isize {
-    let mut sb : stat;
+    let mut sb : stat = ::std::mem::zeroed();
     let mut mtime : isize = 0isize;
     if lstat(file,&mut sb as (*mut stat)) == 0 {
         mtime = sb.st_mtim.tv_sec;
Index: b/src/wrapper.rs
===================================================================
--- a/src/wrapper.rs
+++ b/src/wrapper.rs
@@ -2,7 +2,7 @@ extern {
     fn Xasprintf(format : *const u8, ...) -> *mut u8;
     fn Xstrdup(str : *const u8) -> *mut u8;
     fn __errno_location() -> *mut i32;
-    fn abort();
+    fn abort() -> !;
     static mut current_parsed_root : *mut cvsroot_s;
     fn cvs_temp_name() -> *mut u8;
     fn error(
@@ -33,9 +33,6 @@ extern {
     ) -> isize;
     fn isfile(file : *const u8) -> bool;
     fn isspace(arg1 : i32) -> i32;
-    fn memset(
-        __s : *mut ::std::os::raw::c_void, __c : i32, __n : usize
-    ) -> *mut ::std::os::raw::c_void;
     fn run_exec(
         stin : *const u8, stout : *const u8, sterr : *const u8, flags : i32
     ) -> i32;
@@ -397,17 +394,12 @@ unsafe extern fn streq(
 pub unsafe extern fn wrap_add(mut line : *mut u8, mut isTemp : i32) {
     let mut temp : *mut u8;
     let mut ctemp : u8;
-    let mut e : Struct1;
+    let mut e : Struct1 = ::std::mem::zeroed();
     let mut opt : u8;
     if line.is_null() || *line.offset(
                               0isize
                           ) as (i32) == b'#' as (i32) {
     } else {
-        memset(
-            &mut e as (*mut Struct1) as (*mut ::std::os::raw::c_void),
-            0i32,
-            ::std::mem::size_of::<Struct1>()
-        );
         'loop2: loop {
             if !(*line != 0 && (isspace(*line as (i32)) != 0)) {
                 break;
Index: b/src/log.rs
===================================================================
--- a/src/log.rs
+++ b/src/log.rs
@@ -425,7 +425,7 @@ pub unsafe extern fn cvslog(
     if (*current_parsed_root).isremote {
         let mut p : *mut datelist;
         let mut rp : *mut option_revlist;
-        let mut datetmp : [u8; 50];
+        let mut datetmp = [0u8; 50];
         start_server();
         if is_rlog != 0 && !supported_request((*b"rlog\0").as_ptr()) {
             error(1i32,0i32,(*b"server does not support rlog\0").as_ptr());
@@ -784,8 +784,10 @@ unsafe extern fn rlog_proc(
                     = where_ as (*mut ::std::os::raw::c_void);
                 where_ = dir_append(where_ as (*const u8),d as (*const u8));
                 free(tmp);
-                myargv[0usize] = *argv.offset(0isize);
-                myargv[1usize] = last_component(mfile as (*const u8));
+                myargv = [
+                    *argv.offset(0isize),
+                    last_component(mfile as (*const u8)),
+                ];
                 argc = 2i32;
                 argv = myargv.as_mut_ptr();
                 free(d as (*mut ::std::os::raw::c_void));
@@ -1119,11 +1121,10 @@ unsafe extern fn log_fileproc(
     let mut baserev : *mut u8;
     let mut selrev : i32 = -1i32;
     let mut rcsfile : *mut rcsnode;
-    let mut buf : [u8; 50];
+    let mut buf = [0u8; 50];
     let mut revlist
         : *mut revlist
         = 0i32 as (*mut ::std::os::raw::c_void) as (*mut revlist);
-    let mut log_data_and_rcs : log_data_and_rcs;
     rcsfile = (*finfo).rcs;
     p = findnode((*finfo).entries,(*finfo).file);
     if p != 0i32 as (*mut ::std::os::raw::c_void) as (*mut hashnode) {
@@ -1172,9 +1173,11 @@ unsafe extern fn log_fileproc(
                           (*log_data).default_branch
                       );
             if (*log_data).sup_header != 0 || (*log_data).header == 0 && ((*log_data).long_header == 0) {
-                log_data_and_rcs.log_data = log_data;
-                log_data_and_rcs.revlist = revlist;
-                log_data_and_rcs.rcs = rcsfile;
+                let mut log_data_and_rcs = log_data_and_rcs {
+                    log_data: log_data,
+                    revlist: revlist,
+                    rcs: rcsfile,
+                };
                 if (*log_data).singledatelist != 0i32 as (*mut ::std::os::raw::c_void) as (*mut datelist) {
                     walklist(
                         (*rcsfile).versions,
@@ -2025,13 +2028,13 @@ unsafe extern fn log_version(
     mut trunk : i32
 ) {
     let mut p : *mut hashnode;
-    let mut year : i32;
-    let mut mon : i32;
-    let mut mday : i32;
-    let mut hour : i32;
-    let mut min : i32;
-    let mut sec : i32;
-    let mut buf : [u8; 100];
+    let mut year : i32 = 0;
+    let mut mon : i32 = 0;
+    let mut mday : i32 = 0;
+    let mut hour : i32 = 0;
+    let mut min : i32 = 0;
+    let mut sec : i32 = 0;
+    let mut buf = [0u8; 100];
     let mut padd : *mut hashnode;
     let mut pdel : *mut hashnode;
     if log_version_requested(log_data,revlist,rcs,ver) == 0 {
@@ -2169,10 +2172,10 @@ unsafe extern fn log_version(
                 (*b"openpgp-signatures\0").as_ptr()
             );
         if !p.is_null() {
-            let mut rawsig : *mut u8;
-            let mut rawsiglen : usize;
+            let mut rawsig : *mut u8 = 0 as (*mut u8);
+            let mut rawsiglen : usize = 0;
             let mut membuf : *mut buffer;
-            let mut sig : openpgp_signature;
+            let mut sig : openpgp_signature = ::std::mem::zeroed();
             let mut rc : i32;
             if !base64_decode_alloc_ctx(
                     0i32 as (*mut ::std::os::raw::c_void) as (*mut base64_decode_context),
